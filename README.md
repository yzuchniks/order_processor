## Основные моменты реализации:
1. Использую asyncio.Queue для контроля потока входящих задач. Тут, я передаю фиксированный массив задач, и очередь не имеет особого смысла. 
Но в рабочем варианте, скорее всего, подразумевается постоянное пополнение очереди, поэтому ее размер необходимо ограничивать чтобы избежать переполнения памяти.
2. Обработка идет несколькими воркерами, каждый запускается в фоне, число воркеров можно настраивать. Воркеры завершают работу через сигналы None.
3. Обрабатываю исключения, ретраю, если не помогло помечаю задачу как завершенную ошибкой.
4. Логирую события и ошибки.

## Что еще можно сделать:
1. Отдельно сохранять заказы, упавшие с ошибкой, для последующей обработки и анализа причин ошибки.
2. Тонкая настройка количества воркеров и размера очереди под конкретные условия.
3. Экспоненциальный бэкаф при ретраях.
4. Отслеживать частоту ошибок. При превышении некоего порога за промежуток времени, на время прервать запросы к проблемному ресурсу, дабы не ухудшать ситуацию.
5. Настроить детализированное логирование, сбор метрик и в целом мониторинг.
6. Горизонтальное масштабирование (поднимаем несколько реплик, распределяем нагрузку, повышаем отказоустойчивость).
7. Добавить обработку SIGTERM/SIGINT сигналов, для корректного завершения работы, без потери данных.